<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Territorial.io Клон</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: white;
            overflow: hidden;
            height: 100vh;
        }

        #menu-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
        }

        .menu-container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 40px;
            border-radius: 20px;
            border: 2px solid rgba(255, 255, 255, 0.2);
            text-align: center;
            max-width: 90%;
            width: 400px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 30px;
            background: linear-gradient(45deg, #4cc9f0, #4361ee);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 10px rgba(76, 201, 240, 0.3);
        }

        #country-name {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid #4361ee;
            border-radius: 10px;
            color: white;
            margin-bottom: 20px;
            text-align: center;
        }

        #country-name::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        #play-button {
            width: 100%;
            padding: 15px;
            font-size: 20px;
            font-weight: bold;
            background: linear-gradient(45deg, #4361ee, #3a0ca3);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #play-button:hover, #play-button:active {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(67, 97, 238, 0.4);
        }

        #game-screen {
            display: none;
            width: 100%;
            height: 100vh;
            position: relative;
        }

        #game-container {
            width: 100%;
            height: 100%;
            position: relative;
            overflow: hidden;
        }

        #map {
            background: #2d3748;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: crosshair;
            image-rendering: pixelated;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        #ui-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .country-label {
            position: absolute;
            font-size: 12px;
            font-weight: bold;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
            white-space: nowrap;
            padding: 2px 4px;
            border-radius: 3px;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            min-width: 300px;
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        .troops-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 16px;
        }

        #troops-count {
            font-weight: bold;
            color: #4cc9f0;
            font-size: 18px;
        }

        #percentage-slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        #percentage-slider {
            flex: 1;
            height: 8px;
            -webkit-appearance: none;
            background: linear-gradient(to right, #7209b7, #4361ee);
            border-radius: 4px;
            outline: none;
        }

        #percentage-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            cursor: pointer;
            border: 2px solid #4361ee;
        }

        #percentage-value {
            font-weight: bold;
            color: #4cc9f0;
            min-width: 40px;
        }

        #attack-button {
            background: linear-gradient(45deg, #f72585, #b5179e);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
            pointer-events: auto;
        }

        #attack-button:active {
            transform: scale(0.95);
        }

        #zoom-controls {
            position: absolute;
            right: 20px;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }

        .zoom-button {
            width: 50px;
            height: 50px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .zoom-button:active {
            background: rgba(255, 255, 255, 0.1);
        }

        #attack-indicator {
            position: absolute;
            width: 40px;
            height: 40px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="%23f72585"><path d="M7.5,18C5,18,3,16,3,13.5C3,11,5,9,7.5,9C10,9,12,11,12,13.5C12,16,10,18,7.5,18zM7.5,15C8.3,15,9,14.3,9,13.5C9,12.7,8.3,12,7.5,12C6.7,12,6,12.7,6,13.5C6,14.3,6.7,15,7.5,15z"/></svg>') no-repeat center;
            background-size: contain;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }

        #stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            min-width: 200px;
            pointer-events: auto;
            border: 2px solid rgba(255, 255, 255, 0.1);
        }

        #stats-panel h3 {
            color: #4cc9f0;
            margin-bottom: 10px;
            font-size: 16px;
        }

        #stats-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 14px;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .menu-container {
                padding: 20px;
                width: 95%;
            }
            
            h1 {
                font-size: 2em;
            }
            
            #controls {
                width: 95%;
                min-width: unset;
                padding: 10px;
            }
            
            #zoom-controls {
                right: 10px;
                bottom: 10px;
            }
            
            .zoom-button {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }
            
            #stats-panel {
                left: 10px;
                top: 10px;
                padding: 10px;
                min-width: 150px;
            }
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #1a1a2e;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            font-size: 24px;
        }
    </style>
</head>
<body>
    <div id="loading">Загрузка...</div>
    
    <div id="menu-screen">
        <div class="menu-container">
            <h1>ГЛОБАЛЬНАЯ СТРАТЕГИЯ</h1>
            <input type="text" id="country-name" placeholder="Введите название страны" maxlength="20">
            <button id="play-button">ИГРАТЬ</button>
        </div>
    </div>

    <div id="game-screen">
        <div id="game-container">
            <canvas id="map"></canvas>
            <div id="ui-overlay"></div>
            <div id="attack-indicator"></div>
            
            <div id="stats-panel">
                <h3>Страны</h3>
                <div id="stats-list"></div>
            </div>
            
            <div id="controls">
                <div class="troops-display">
                    <span id="player-country-name">Страна</span>
                    <span id="troops-count">100</span>
                </div>
                <div id="percentage-slider-container">
                    <span>Войска:</span>
                    <input type="range" id="percentage-slider" min="10" max="100" value="50" step="10">
                    <span id="percentage-value">50%</span>
                </div>
                <button id="attack-button">АТАКОВАТЬ</button>
            </div>
            
            <div id="zoom-controls">
                <button class="zoom-button" id="zoom-in">+</button>
                <button class="zoom-button" id="zoom-out">-</button>
                <button class="zoom-button" id="reset-zoom">⟲</button>
            </div>
        </div>
    </div>

    <script>
        // Загрузка сохранённого имени
        document.addEventListener('DOMContentLoaded', () => {
            const loading = document.getElementById('loading');
            loading.style.display = 'none';
            
            const savedName = localStorage.getItem('countryName');
            if (savedName) {
                document.getElementById('country-name').value = savedName;
            }
        });

        // Константы игры
        const MAP_SIZE = 2000;
        const CELL_SIZE = 20;
        const GRID_SIZE = MAP_SIZE / CELL_SIZE;
        const BOT_NAMES = ['Франция', 'Німеччина', 'Італія', 'Іспанія', 'Польща', 'Чехія', 'Норвегія', 'Швеція', 'Греція', 'Португалія'];
        const PLAYER_COLOR = '#4361ee';
        const BOT_COLORS = [
            '#f72585', '#b5179e', '#7209b7', '#560bad',
            '#480ca8', '#3a0ca3', '#3f37c9', '#4361ee',
            '#4895ef', '#4cc9f0'
        ];

        // Состояние игры
        let gameState = {
            player: null,
            bots: [],
            cells: [],
            selectedCell: null,
            attackPercentage: 50,
            zoom: 1,
            offsetX: 0,
            offsetY: 0,
            isDragging: false,
            lastX: 0,
            lastY: 0,
            lastAttackTime: 0,
            attackCooldown: 1000 // 1 секунда между атаками
        };

        // Инициализация игры
        function initGame() {
            const countryName = document.getElementById('country-name').value.trim();
            if (!countryName) {
                alert('Введите название страны!');
                return;
            }
            
            // Сохраняем имя
            localStorage.setItem('countryName', countryName);
            
            // Скрываем меню, показываем игру
            document.getElementById('menu-screen').style.display = 'none';
            document.getElementById('game-screen').style.display = 'block';
            document.getElementById('player-country-name').textContent = countryName;
            
            // Инициализируем канвас
            const canvas = document.getElementById('map');
            const container = document.getElementById('game-container');
            canvas.width = MAP_SIZE;
            canvas.height = MAP_SIZE;
            
            // Создаём игрока
            gameState.player = {
                name: countryName,
                color: PLAYER_COLOR,
                borderColor: '#2a4dcc',
                troops: 100,
                territories: []
            };
            
            // Создаём ботов
            gameState.bots = [];
            const usedNames = new Set();
            const usedColors = new Set([PLAYER_COLOR]);
            
            for (let i = 0; i < 10; i++) {
                let name, color;
                do {
                    name = BOT_NAMES[Math.floor(Math.random() * BOT_NAMES.length)];
                } while (usedNames.has(name));
                
                do {
                    color = BOT_COLORS[Math.floor(Math.random() * BOT_COLORS.length)];
                } while (usedColors.has(color));
                
                usedNames.add(name);
                usedColors.add(color);
                
                gameState.bots.push({
                    name: name,
                    color: color,
                    borderColor: darkenColor(color, 30),
                    troops: 100,
                    territories: [],
                    lastAction: 0,
                    actionCooldown: 2000 + Math.random() * 3000
                });
            }
            
            // Инициализируем клетки
            gameState.cells = [];
            for (let y = 0; y < GRID_SIZE; y++) {
                gameState.cells[y] = [];
                for (let x = 0; x < GRID_SIZE; x++) {
                    gameState.cells[y][x] = {
                        owner: null,
                        troops: 0,
                        x: x * CELL_SIZE,
                        y: y * CELL_SIZE
                    };
                }
            }
            
            // Спавним игрока в случайном месте
            spawnPlayer();
            
            // Спавним ботов
            spawnBots();
            
            // Запускаем игровой цикл
            requestAnimationFrame(gameLoop);
            
            // Инициализируем UI
            updateStats();
        }

        // Спавн игрока
        function spawnPlayer() {
            const x = Math.floor(GRID_SIZE / 4 + Math.random() * GRID_SIZE / 2);
            const y = Math.floor(GRID_SIZE / 4 + Math.random() * GRID_SIZE / 2);
            
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        const cell = gameState.cells[ny][nx];
                        cell.owner = gameState.player;
                        cell.troops = 10;
                        gameState.player.territories.push({x: nx, y: ny});
                    }
                }
            }
            gameState.player.troops = 100;
        }

        // Спавн ботов
        function spawnBots() {
            const centerX = GRID_SIZE / 2;
            const centerY = GRID_SIZE / 2;
            const radius = GRID_SIZE / 3;
            
            gameState.bots.forEach((bot, index) => {
                const angle = (index / gameState.bots.length) * Math.PI * 2;
                const distance = radius * (0.8 + Math.random() * 0.4);
                const x = Math.floor(centerX + Math.cos(angle) * distance);
                const y = Math.floor(centerY + Math.sin(angle) * distance);
                
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                            const cell = gameState.cells[ny][nx];
                            if (!cell.owner) {
                                cell.owner = bot;
                                cell.troops = 10;
                                bot.territories.push({x: nx, y: ny});
                            }
                        }
                    }
                }
                bot.troops = 100;
            });
        }

        // Игровой цикл
        function gameLoop() {
            updateGame();
            renderGame();
            requestAnimationFrame(gameLoop);
        }

        // Обновление игры
        function updateGame() {
            const now = Date.now();
            
            // Генерация войск
            gameState.player.troops += Math.floor(gameState.player.territories.length / 10) + 1;
            
            gameState.bots.forEach(bot => {
                bot.troops += Math.floor(bot.territories.length / 10) + 1;
            });
            
            // Логика ботов
            gameState.bots.forEach(bot => {
                if (now - bot.lastAction > bot.actionCooldown) {
                    botAction(bot);
                    bot.lastAction = now;
                    bot.actionCooldown = 2000 + Math.random() * 3000;
                }
            });
            
            // Обновляем отображение войск
            document.getElementById('troops-count').textContent = gameState.player.troops;
            updateStats();
        }

        // Действия ботов
        function botAction(bot) {
            if (bot.territories.length === 0 || bot.troops < 10) return;
            
            const actionType = Math.random();
            const borderCells = getBorderCells(bot);
            
            if (borderCells.length === 0) return;
            
            const targetCell = borderCells[Math.floor(Math.random() * borderCells.length)];
            const percentage = 20 + Math.random() * 60;
            
            if (targetCell.owner === null) {
                // Атака нейтральной территории
                attackTerritory(bot, targetCell, percentage);
            } else if (targetCell.owner !== bot && Math.random() > 0.7) {
                // Атака врага (с меньшей вероятностью)
                attackTerritory(bot, targetCell, percentage);
            }
        }

        // Получение граничных клеток
        function getBorderCells(owner) {
            const borderCells = [];
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0]];
            
            owner.territories.forEach(territory => {
                const {x, y} = territory;
                
                directions.forEach(([dx, dy]) => {
                    const nx = x + dx;
                    const ny = y + dy;
                    
                    if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                        const cell = gameState.cells[ny][nx];
                        if (cell.owner !== owner && cell.owner !== gameState.player) {
                            borderCells.push(cell);
                        }
                    }
                });
            });
            
            return borderCells;
        }

        // Атака территории
        function attackTerritory(attacker, targetCell, percentage) {
            if (!attacker || !targetCell || attacker.troops < 10) return false;
            
            const attackingTroops = Math.floor(attacker.troops * (percentage / 100));
            if (attackingTroops < 1) return false;
            
            attacker.troops -= attackingTroops;
            
            // Находим ближайшую территорию атакующего
            let nearestTerritory = null;
            let minDistance = Infinity;
            
            attacker.territories.forEach(territory => {
                const dx = territory.x - Math.floor(targetCell.x / CELL_SIZE);
                const dy = territory.y - Math.floor(targetCell.y / CELL_SIZE);
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < minDistance) {
                    minDistance = distance;
                    nearestTerritory = territory;
                }
            });
            
            if (!nearestTerritory) return false;
            
            // Захват территории
            setTimeout(() => {
                if (targetCell.owner === null) {
                    // Нейтральная территория
                    targetCell.owner = attacker;
                    targetCell.troops = attackingTroops;
                    attacker.territories.push({
                        x: Math.floor(targetCell.x / CELL_SIZE),
                        y: Math.floor(targetCell.y / CELL_SIZE)
                    });
                } else if (targetCell.owner !== attacker) {
                    // Территория врага
                    if (attackingTroops > targetCell.troops) {
                        const prevOwner = targetCell.owner;
                        prevOwner.territories = prevOwner.territories.filter(t => 
                            !(t.x === Math.floor(targetCell.x / CELL_SIZE) && 
                              t.y === Math.floor(targetCell.y / CELL_SIZE))
                        );
                        
                        targetCell.owner = attacker;
                        targetCell.troops = attackingTroops - targetCell.troops;
                        attacker.territories.push({
                            x: Math.floor(targetCell.x / CELL_SIZE),
                            y: Math.floor(targetCell.y / CELL_SIZE)
                        });
                    } else {
                        targetCell.troops -= attackingTroops;
                    }
                }
            }, 500);
            
            return true;
        }

        // Отрисовка игры
        function renderGame() {
            const canvas = document.getElementById('map');
            const ctx = canvas.getContext('2d');
            const container = document.getElementById('game-container');
            
            // Очистка канваса
            ctx.fillStyle = '#2d3748';
            ctx.fillRect(0, 0, MAP_SIZE, MAP_SIZE);
            
            // Применяем трансформации для зума и панорамирования
            ctx.save();
            ctx.translate(container.clientWidth / 2, container.clientHeight / 2);
            ctx.scale(gameState.zoom, gameState.zoom);
            ctx.translate(gameState.offsetX, gameState.offsetY);
            ctx.translate(-MAP_SIZE / 2, -MAP_SIZE / 2);
            
            // Рисуем сетку (только при малом зуме)
            if (gameState.zoom > 0.5) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
                ctx.lineWidth = 1;
                
                for (let x = 0; x <= GRID_SIZE; x++) {
                    ctx.beginPath();
                    ctx.moveTo(x * CELL_SIZE, 0);
                    ctx.lineTo(x * CELL_SIZE, MAP_SIZE);
                    ctx.stroke();
                }
                
                for (let y = 0; y <= GRID_SIZE; y++) {
                    ctx.beginPath();
                    ctx.moveTo(0, y * CELL_SIZE);
                    ctx.lineTo(MAP_SIZE, y * CELL_SIZE);
                    ctx.stroke();
                }
            }
            
            // Рисуем территории
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const cell = gameState.cells[y][x];
                    if (cell.owner) {
                        ctx.fillStyle = cell.owner.color;
                        ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                        
                        // Граница территории
                        ctx.strokeStyle = cell.owner.borderColor;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                    }
                }
            }
            
            // Рисуем метки стран
            drawCountryLabels();
            
            ctx.restore();
        }

        // Отрисовка меток стран
        function drawCountryLabels() {
            const uiOverlay = document.getElementById('ui-overlay');
            uiOverlay.innerHTML = '';
            
            // Метка игрока
            if (gameState.player.territories.length > 0) {
                const firstTerritory = gameState.player.territories[0];
                const screenPos = worldToScreen(firstTerritory.x * CELL_SIZE, firstTerritory.y * CELL_SIZE);
                
                const label = document.createElement('div');
                label.className = 'country-label';
                label.textContent = `${gameState.player.name} (${gameState.player.troops})`;
                label.style.left = screenPos.x + 'px';
                label.style.top = screenPos.y + 'px';
                label.style.color = PLAYER_COLOR;
                uiOverlay.appendChild(label);
            }
            
            // Метки ботов
            gameState.bots.forEach(bot => {
                if (bot.territories.length > 0) {
                    const firstTerritory = bot.territories[0];
                    const screenPos = worldToScreen(firstTerritory.x * CELL_SIZE, firstTerritory.y * CELL_SIZE);
                    
                    const label = document.createElement('div');
                    label.className = 'country-label';
                    label.textContent = `${bot.name} (${bot.troops})`;
                    label.style.left = screenPos.x + 'px';
                    label.style.top = screenPos.y + 'px';
                    label.style.color = bot.color;
                    uiOverlay.appendChild(label);
                }
            });
        }

        // Обновление статистики
        function updateStats() {
            const statsList = document.getElementById('stats-list');
            statsList.innerHTML = '';
            
            // Игрок
            const playerItem = document.createElement('div');
            playerItem.className = 'stat-item';
            playerItem.innerHTML = `
                <span style="color: ${PLAYER_COLOR}">${gameState.player.name}</span>
                <span>${gameState.player.troops} | ${gameState.player.territories.length}</span>
            `;
            statsList.appendChild(playerItem);
            
            // Боты
            gameState.bots.forEach(bot => {
                const item = document.createElement('div');
                item.className = 'stat-item';
                item.innerHTML = `
                    <span style="color: ${bot.color}">${bot.name}</span>
                    <span>${bot.troops} | ${bot.territories.length}</span>
                `;
                statsList.appendChild(item);
            });
        }

        // Преобразование мировых координат в экранные
        function worldToScreen(worldX, worldY) {
            const container = document.getElementById('game-container');
            const screenX = container.clientWidth / 2 + (worldX - MAP_SIZE / 2 + gameState.offsetX) * gameState.zoom;
            const screenY = container.clientHeight / 2 + (worldY - MAP_SIZE / 2 + gameState.offsetY) * gameState.zoom;
            return { x: screenX, y: screenY };
        }

        // Преобразование экранных координат в мировые
        function screenToWorld(screenX, screenY) {
            const container = document.getElementById('game-container');
            const worldX = (screenX - container.clientWidth / 2) / gameState.zoom - gameState.offsetX + MAP_SIZE / 2;
            const worldY = (screenY - container.clientHeight / 2) / gameState.zoom - gameState.offsetY + MAP_SIZE / 2;
            return { x: worldX, y: worldY };
        }

        // Затемнение цвета для границ
        function darkenColor(color, percent) {
            const num = parseInt(color.slice(1), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) - amt;
            const G = (num >> 8 & 0x00FF) - amt;
            const B = (num & 0x0000FF) - amt;
            
            return '#' + (
                0x1000000 +
                (R < 255 ? R < 1 ? 0 : R : 255) * 0x10000 +
                (G < 255 ? G < 1 ? 0 : G : 255) * 0x100 +
                (B < 255 ? B < 1 ? 0 : B : 255)
            ).toString(16).slice(1);
        }

        // Обработчики событий
        document.getElementById('play-button').addEventListener('click', initGame);
        
        document.getElementById('country-name').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                initGame();
            }
        });

        document.getElementById('percentage-slider').addEventListener('input', (e) => {
            gameState.attackPercentage = parseInt(e.target.value);
            document.getElementById('percentage-value').textContent = gameState.attackPercentage + '%';
        });

        document.getElementById('attack-button').addEventListener('click', () => {
            if (gameState.selectedCell) {
                const now = Date.now();
                if (now - gameState.lastAttackTime >= gameState.attackCooldown) {
                    if (attackTerritory(gameState.player, gameState.selectedCell, gameState.attackPercentage)) {
                        gameState.lastAttackTime = now;
                        
                        // Анимация атаки
                        const indicator = document.getElementById('attack-indicator');
                        const screenPos = worldToScreen(gameState.selectedCell.x, gameState.selectedCell.y);
                        indicator.style.left = (screenPos.x - 20) + 'px';
                        indicator.style.top = (screenPos.y - 20) + 'px';
                        indicator.style.opacity = '1';
                        
                        setTimeout(() => {
                            indicator.style.opacity = '0';
                        }, 500);
                    }
                }
            }
        });

        // Обработка кликов по карте
        const canvas = document.getElementById('map');
        canvas.addEventListener('click', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            const worldPos = screenToWorld(x, y);
            const gridX = Math.floor(worldPos.x / CELL_SIZE);
            const gridY = Math.floor(worldPos.y / CELL_SIZE);
            
            if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
                const cell = gameState.cells[gridY][gridX];
                
                // Проверяем, граничит ли клетка с территорией игрока
                const isBorder = isBorderCell(gridX, gridY, gameState.player);
                
                if (isBorder && cell.owner !== gameState.player) {
                    gameState.selectedCell = cell;
                    
                    // Показываем индикатор выбора
                    const indicator = document.getElementById('attack-indicator');
                    const screenPos = worldToScreen(cell.x, cell.y);
                    indicator.style.left = (screenPos.x - 20) + 'px';
                    indicator.style.top = (screenPos.y - 20) + 'px';
                    indicator.style.opacity = '0.5';
                }
            }
        });

        // Проверка, является ли клетка граничной
        function isBorderCell(x, y, owner) {
            const directions = [[0, 1], [1, 0], [0, -1], [-1, 0], 
                              [1, 1], [1, -1], [-1, 1], [-1, -1]];
            
            for (const [dx, dy] of directions) {
                const nx = x + dx;
                const ny = y + dy;
                
                if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE) {
                    const neighbor = gameState.cells[ny][nx];
                    if (neighbor.owner === owner) {
                        return true;
                    }
                }
            }
            return false;
        }

        // Управление зумом
        document.getElementById('zoom-in').addEventListener('click', () => {
            gameState.zoom = Math.min(gameState.zoom * 1.2, 3);
        });

        document.getElementById('zoom-out').addEventListener('click', () => {
            gameState.zoom = Math.max(gameState.zoom / 1.2, 0.2);
        });

        document.getElementById('reset-zoom').addEventListener('click', () => {
            gameState.zoom = 1;
            gameState.offsetX = 0;
            gameState.offsetY = 0;
        });

        // Панорамирование
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        });

        document.addEventListener('mousemove', (e) => {
            if (isDragging) {
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                gameState.offsetX += dx / gameState.zoom;
                gameState.offsetY += dy / gameState.zoom;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
            }
        });

        document.addEventListener('mouseup', () => {
            isDragging = false;
            canvas.style.cursor = 'crosshair';
        });

        // Сенсорные события для мобильных устройств
        let lastTouchDistance = 0;

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                isDragging = true;
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Мультитач для зума
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastTouchDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
            }
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1 && isDragging) {
                const dx = e.touches[0].clientX - lastMouseX;
                const dy = e.touches[0].clientY - lastMouseY;
                
                gameState.offsetX += dx / gameState.zoom;
                gameState.offsetY += dy / gameState.zoom;
                
                lastMouseX = e.touches[0].clientX;
                lastMouseY = e.touches[0].clientY;
            } else if (e.touches.length === 2) {
                // Обработка зума двумя пальцами
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                const currentDistance = Math.sqrt(
                    Math.pow(touch2.clientX - touch1.clientX, 2) +
                    Math.pow(touch2.clientY - touch1.clientY, 2)
                );
                
                if (lastTouchDistance > 0) {
                    const zoomFactor = currentDistance / lastTouchDistance;
                    gameState.zoom = Math.max(0.2, Math.min(3, gameState.zoom * zoomFactor));
                }
                
                lastTouchDistance = currentDistance;
            }
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            isDragging = false;
            lastTouchDistance = 0;
        });

        // Запрещаем контекстное меню
        canvas.addEventListener('contextmenu', (e) => {
            e.preventDefault();
        });
    </script>
</body>
</html>
